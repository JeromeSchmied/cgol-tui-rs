use super::*;

fn gen_uni(area: Area, cells: &[bool]) -> Universe {
    let cells = cells.iter().map(|c| (*c).into()).collect::<Vec<Cell>>();
    Universe { area, cells }
}

#[test]
fn parse0() {
    let figur = "\
..O
OO..O

...O
..O";
    let univ = Universe::from_str(figur);
    let cells = [
        /* 1st row */ false, false, true, false, false, /* 2nd row */ true, true, false,
        false, true, /* 3rd row */ false, false, false, false, false,
        /* 4th row */ false, false, false, true, false, /* 5th row */ false, false, true,
        false, false,
    ];
    let area = Area::new(5, 5);
    assert_eq!(gen_uni(area, &cells), univ);
}

#[test]
fn full() {
    let area = Area::new(20, 20);
    let full = shapes::full(area);
    let cells = vec![true; area.len()];
    let uni = gen_uni(area, &cells);
    assert_eq!(full, uni);
}
#[test]
fn halp() {
    let area = Area::new(2, 2);
    let cells = vec![false, true, true, false];
    let univ = gen_uni(area, &cells);

    let idx: (u8, u8) = (0, 0);
    let x = univ[idx];
    assert_eq!(x, false.into());
    assert_eq!(univ.get(idx), Some(&x));

    let idx: (u8, u8) = (0, 1);
    let x = univ[idx];
    assert_eq!(x, true.into());
    assert_eq!(univ.get(idx), Some(&x));

    let idx: (u8, u8) = (1, 0);
    let x = univ[idx];
    assert_eq!(x, true.into());
    assert_eq!(univ.get(idx), Some(&x));

    let idx: (u8, u8) = (1, 1);
    let x = univ[idx];
    assert_eq!(x, false.into());
    assert_eq!(univ.get(idx), Some(&x));
}

#[test]
fn bigass_tickler() {
    let area = Area::new(8, 8);
    let mut univ =
        Universe::from_figur(area, Universe::from_str(shapes::FEATHERWEIGTH_SPACESHIP)).unwrap();

    let exp_unis = [
        "\
........
........
....O...
..O.O...
...OO...
........
........
........",
        "\
........
........
...O....
....OO..
...OO...
........
........
........",
        "\
........
........
....O...
.....O..
...OOO..
........
........
........",
        "\
........
........
........
...O.O..
....OO..
....O...
........
........",
        "\
........
........
........
.....O..
...O.O..
....OO..
........
........",
        "\
........
........
........
....O...
.....OO.
....OO..
........
........",
        "\
........
........
........
.....O..
......O.
....OOO.
........
........",
        "\
........
........
........
........
....O.O.
.....OO.
.....O..
........",
        "\
........
........
........
........
......O.
....O.O.
.....OO.
........",
        "\
........
........
........
........
.....O..
......OO
.....OO.
........",
        "\
........
........
........
........
......O.
.......O
.....OOO
........",
        "\
........
........
........
........
........
.....O.O
......OO
......O.",
        "\
........
........
........
........
........
.......O
.....O.O
......OO",
        "\
........
........
........
........
........
......O.
O......O
......OO",
        "\
........
........
........
........
........
.......O
O.......
O.....OO",
        "\
.......O
........
........
........
........
........
O.....O.
O......O",
        "\
O......O
........
........
........
........
........
O.......
O.....O.",
        "\
O......O
........
........
........
........
........
.......O
OO......",
        "\
OO.....O
........
........
........
........
........
O.......
.O......",
        "\
OO......
O.......
........
........
........
........
........
.O.....O",
        "\
.O.....O
OO......
........
........
........
........
........
.O......",
        "\
.OO.....
OO......
........
........
........
........
........
O.......",
        "\
..O.....
OOO.....
........
........
........
........
........
.O......",
        "\
O.O.....
.OO.....
.O......
........
........
........
........
........",
        "\
..O.....
O.O.....
.OO.....
........
........
........
........
........",
        "\
.O......
..OO....
.OO.....
........
........
........
........
........",
        "\
..O.....
...O....
.OOO....
........
........
........
........
........",
        "\
........
.O.O....
..OO....
..O.....
........
........
........
........",
        "\
........
...O....
.O.O....
..OO....
........
........
........
........",
        "\
........
..O.....
...OO...
..OO....
........
........
........
........",
        "\
........
...O....
....O...
..OOO...
........
........
........
........",
        "\
........
........
..O.O...
...OO...
...O....
........
........
........",
        "\
........
........
....O...
..O.O...
...OO...
........
........
........",
    ];

    for exp_uni in exp_unis.map(Universe::from_str) {
        println!("exp univ:\n{exp_uni}");
        println!("univ:\n{univ}");
        assert_eq!(univ, exp_uni);
        univ.tick();
    }
}

#[test]
fn neighbours() {
    let univ = Universe::from_str(
        "\
.O.O
.OO.
..O.
..O.",
    );
    let nghbrs = |coord: (u16, u16)| -> u8 { univ.live_neighbour_count(coord.0, coord.1) };

    // 1. row
    assert_eq!(nghbrs((0, 0)), 3);
    assert_eq!(nghbrs((0, 1)), 3);
    assert_eq!(nghbrs((0, 2)), 5);
    assert_eq!(nghbrs((0, 3)), 2);

    // 2. row
    assert_eq!(nghbrs((1, 0)), 3);
    assert_eq!(nghbrs((1, 1)), 3);
    assert_eq!(nghbrs((1, 2)), 4);
    assert_eq!(nghbrs((1, 3)), 3);

    // 3. row
    assert_eq!(nghbrs((2, 0)), 1);
    assert_eq!(nghbrs((2, 1)), 4);
    assert_eq!(nghbrs((2, 2)), 3);
    assert_eq!(nghbrs((2, 3)), 3);

    // 4. row
    assert_eq!(nghbrs((3, 0)), 2);
    assert_eq!(nghbrs((3, 1)), 3);
    assert_eq!(nghbrs((3, 2)), 3);
    assert_eq!(nghbrs((3, 3)), 3);
}
